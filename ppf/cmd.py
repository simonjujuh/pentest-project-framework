#!/usr/bin/env python3
# -*- encoding: utf-8 -*-

import os
import re
import sys
import cmd
import configparser


class PPFCmd(cmd.Cmd):
    """Command line interpreter"""

    def __init__(self, config_path):
        cmd.Cmd.__init__(self)
        self.prompt = 'ppf > '
        self.config_path = config_path

        try:
            self.config = configparser.ConfigParser()
            self.config.read(self.config_path)
        except Exception as e:
            print("[-] Error reading ppf.conf: {}".format(e))
            sys.exit(1)
        
        self.project_basedir = self.config.get('projects', 'projects_directory')
        if not os.path.isdir(self.project_basedir):
            print("[-] Error creating cmd: {} is not a directory".format(self.project_basedir))
            sys.exit(1)
        
        self.update_available_projects()

        #prompt password here
        #self.keepass_db = self.config.get('encryption', 'keepassxc_kdbx')
        #self.keepass_file = self.config.get('encryption', 'keepassxc_kdbx')
        #...

    def update_available_projects(self):
        self.available_projects = [d for d in os.listdir(self.project_basedir) if os.path.isdir(os.path.join(self.project_basedir, d))]
        self.available_projects.sort()

    def complete_available_projects(self, text, line, begidx, endidx):
        pass

    def help_create(self):
        """Display help for the create command"""
        print("usage: create <project>")
        print("")
        print("description:")
        print("  create a new project in {}".format(self.project_basedir))
        print("  the project name must be a mix of upper, lower, numbers")
        print("  and some special characters (`.-_`)")

    def do_create(self, arg):
        """Create a new pentest project directory"""
        pattern = re.compile("^[A-Za-z0-9_.\-]+$")
        if not pattern.match(arg):
            print('[-] Error checking project name: project is invalid')
        elif arg in self.available_projects:
            print(f'[-] Error creating project: {arg} already exists')
        else:
            os.mkdir(os.path.join(self.project_basedir, arg))
            print(f'[+] Project \'{arg}\' created successfully')
            self.update_available_projects()
        print("")
        
    def complete_create(self, text, line, begidx, endidx):
        """Autocomplete the pentest project list when typing <TAB><TAB>"""
        completions = self.available_projects
        mline = line.partition(' ')[2]
        offs = len(mline) - len(text)
        return [s[offs:] for s in completions if s.startswith(mline)]

    def help_list(self):
        """Display help for the list command"""
        print("usage: list")
        print("")
        print("description:")
        print("  list available projects on the filesystem")

    def do_list(self, args):
        """Display"""
        print('[*] Available projects:')
        for project in self.available_projects:
            print(f'  - {project}')
        print("")


    def do_encrypt(self, args):
        """TODO"""
        # args correspond à la liste des projets séparés par des espaces
        # on split chacun des projets
        # on demande la clé de chiffrement du keepass
        # on fait la connexion au keepass
        #   cas avec clé
        #   cas sans clé
        #   on verifie que ce dernier soit bien configuré
        # recupère les informations relatives à keepass
        # la db doit exister

        # si la clé est configurée lle doit existe
        # si la clé n'est pas configurée, on continue
        # si la clé est configurée, elle doit exister

        print('.')
        
    
    def help_encrypt(self):
        print('Not implemented.')
        pass

    def do_archive(self, args):
        print('Not implemented.')
        pass
    
    def help_archive(self):
        print('Not implemented.')
        pass

    def do_quit(self, args):
        """Quits the program."""
        print("Quitting.")
        raise SystemExit